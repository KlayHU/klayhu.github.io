<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>顺丰集团java实习生一面</title>
    <link href="undefined2020/07/02/%E9%A1%BA%E4%B8%B0%E9%9B%86%E5%9B%A2java%E5%AE%9E%E4%B9%A0%E7%94%9F%E4%B8%80%E9%9D%A2/"/>
    <url>2020/07/02/%E9%A1%BA%E4%B8%B0%E9%9B%86%E5%9B%A2java%E5%AE%9E%E4%B9%A0%E7%94%9F%E4%B8%80%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<h3 id="顺丰集团java实习生一面-深圳">顺丰集团java实习生一面 · 深圳</h3><hr><p>​面试时间是在6月11号下午两点半到三点，已经面过大半个月了，因为最近考试的原因，现在才在这里写下面经。接下来我就描述总结一下一面的过程：</p><ol><li>自我介绍</li><li>项目介绍</li><li>聊一聊数据库的分库分表</li><li>二叉树排序</li><li>手写快速排序</li><li>http协议的理解</li></ol><p>​        面试官接入视频之后开场就说面试时间有限，能简答就简答。虽然开场就给我不是很多深入思考的时间，但是面试官人还是很不错的，在我回答的时候会提醒我概念上答的不完善的地方，告诉我别紧张。（哈哈，我真的有些紧张，原因后面讲）</p><p>​面试过程相对短暂，一共二十多分钟，不到半小时，但是该问的面基本都覆盖到了。首先项目介绍，面试官对实验室横的向课题似乎比较感兴趣，除了了解之外还问了问有没有实现产品化。其他的数据库和计算机网络那里都是穿插着小知识点问的，比较友好，没有一个操作十连问问到底层具体。大体上我觉得二叉树排序那里答得不好，我对这个的理解仅仅停留在二叉树的遍历方式，一直在答这个，然是感觉面试官有些不满意，应该是我漏掉了重点，网上后来查二叉树查找过程才发现我跑题了。。因为关于二叉树的应用我准备的并不充分，算是相较薄弱的一环，如果深入问的话我可能就一时反应不上来。（人菜多读书）</p><p>​最后讲一讲那天我的情况。我之前预约的科二考试是6月12号进行，但是6月11号那天我在考场模拟科二，从中午十二点到下午四点。。。之前收到面试短信是10号下午四点，那会刚刚把模拟时间定下来，这下时间算是冲突了，我不得不在模拟中途下车去到考务中心的食堂准备。（那个时段食堂比较安静，靠窗环境亮度还不错）时间真是太巧了，哈哈。。</p><hr><h3 id="知识点">知识点&amp;</h3><ul><li>数据库分库分表</li></ul><p><strong>分库分表是为了解决由于数据量过大而导致数据库性能降低的问题，将原来独立的数据库拆分成若干数据库组成，将数据大表拆分成数据表组成，使得单一数据库、单一数据表的数据量变小，从而达到提升数据库性能的目的。</strong></p><p>分库分表包括分库和分表两个部分，在生产中通常包括：垂直分库、水平分库、垂直分表、水平分表四种方式。</p><p><strong>垂直拆分</strong>（缓解单集群压力）</p><ol><li>垂直分表</li></ol><p>​        基于字段进行分表，一般对表中字段数据较大，长度较长（text类型）的拆分到“扩展表”，或者根据访问字段的频率进行分表，对低频字段和高频字段进行分表。避免查询时数据量太大造成的跨页问题。</p><!--同一张表，不同字段放在同一个数据库中--><ol start="2"><li>垂直分库</li></ol><p>​        垂直分库针对的是一个系统中的不同业务进行拆分，比如用户、商品、订单各一个库。切分后要放在多个服务器上，而不是一个服务器。因为服务器在提供CURD服务的时候，需要访问的数据量过大，在没拆分之前都是在一个库上进行，因此每个表还是竞争同一个物理机的CPU、内存、网络IO、磁盘。这会让数据处理直接影响系统性能，部署在多个服务器上解决了单机资源问题。</p><ul><li>解决业务层面耦合，业务清晰；</li><li>能对不同业务的数据进行分级管理、维护、监控、扩展等；</li><li>高并发场景下，垂直分库能够提升IO、数据库连接数</li></ul><p><strong>水平拆分</strong></p><ol><li>水平分表</li></ol><p>与水平分库思路类似，水平分表操作数据表，把数据分到多套表中。在同一个数据库内，把同一个表的数据按一定规则拆到多个表中。</p><ul><li>优化单一表数据过大而产生的性能问题；</li><li>避免IO争抢并减少锁表几率；</li></ul><!--对数据行的操作，不影响表结构--><ol start="2"><li>水平分库</li></ol><p>​        对于电商应用场景，如果店铺数和每家店铺的商品数都较多，那么单表查询显然不可能运行在合理范围内。这时，就要使用水平分库。即：按照一定规则进行分库，以ID为例。如果店铺ID为奇数，则将此操作映射到product_singleDB中；如果店铺ID为偶数，则将次操作映射到product_doubleDB中。</p><p>​当一个应用难以在用细粒度进行垂直切分，或切分后数据量巨大、存在单库读写这时候就需要进行水平分库。<strong>但由于同一个表被分配到不同的数据库中，数据库实例较多需要额外进行数据操作的路由工作，因此却又提升了系统的复杂度。</strong></p><!--对比垂直分库，垂直分库是把不同表拆到不同库里，是数据行的拆分，不影响表结构--><p>🔽 限于篇幅，下一篇继续</p>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go语言学习笔记（三）</title>
    <link href="undefined2019/11/27/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <url>2019/11/27/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="day05">##Day05  :</h2><p>🌍<strong>并发编程</strong>🌏</p><h3 id="goroutine">goroutine  :</h3><p><strong>轻量级“线程“;</strong></p><p><strong>非抢占式多任务处理，由协程主动交出控制权;</strong></p><p><strong>编译器/解释器/虚拟机层面的多任务，具体执行由调度器完成;</strong></p><p><strong>多个协程可以在一个或多个线程上运行;</strong></p><pre><code class="language-go">func main(){       var a [10] int    for i := 0 ;i&lt;10 ;i++{        go func(i int){            for{                            a[i]++                //runtime.Gosched()  //交出控制权，让其他goroutine有运行机会            }              }(i)    }       time.Sleep(time.Millisecond)    fmt.Println(a)}</code></pre><p>上面的代码简单展示了协程的工作方式，在函数前加上关键字go，表明这个函数交给main协程以外的协程由调度器执行，调度器会在合适的点进行切换。而关于协程相较于线程的轻量级，在于其主协程(main)和其他协程(…goroutine)可以相互访问。如下图：</p><p><img src="/2019/11/27/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/%E5%8D%8F%E7%A8%8BCoroutine.png" srcset="undefined" alt="协程Coroutine"></p><p>Go语言原生支持协程，Java的一些第三方的JVM对协程支持。</p><h4 id="goroutine-u-可能-u-切换的点：">goroutine<u>可能</u>切换的点：</h4><p><strong>I/O,select</strong></p><p><strong>channel</strong></p><p><strong>等待锁</strong></p><p><strong>函数调用</strong></p><p><strong>runtime.Gosched()</strong></p><p>⚠️<strong>多个协程会映射到一个线程里</strong></p><h3 id="channel-：">channel  ：</h3><p>🍨Go语言创造者：</p><p><strong>''不要通过共享内存来通信；通过通信来共享内存</strong>’’</p><pre><code class="language-go">import (       &quot;fmt&quot;    &quot;time&quot;)func worker(id int , c chan int) {    for{        n,ok := &lt;-c        if !ok{            break        }        fmt.Printf(&quot;Worker %d receive %d\n&quot;,id,n)    }}func createWorker(id int)chan &lt;- int {// &lt;- 定义这个channel是用来发数据的    c := make(chan int)    go worker(id,c)    return c}func channelDemo(){    //c == nil    //channel of int  channel里面的内容是int       var channels [10] chan &lt;- int       for i := 0; i&lt;10 ; i++{        channels [i] = createWorker(i)    }       for i:= 0 ; i&lt;10 ;i++{        channels[i] &lt;- 'A'+i       }       //n := &lt;-c             //收数据       //fmt.Println(s)            //直接运行会报deadlock    time.Sleep(time.Millisecond)}func bufferedChannel(){   //只有发没有收的channel会产生死锁    n := make(chan int , 3)  //设置缓冲区,不会产生deadlock    go worker(0,n)    n &lt;- 'a'    n &lt;- 'b'     n &lt;- 'c'    time.Sleep(time.Millisecond)}func channelClose(){    n := make(chan int , 3)//设置缓冲区,不会产生deadlock    go worker(0,n)    n &lt;- 'a'    n &lt;- 'b'    n &lt;- 'c'    close(n)    //会收到许多空数据    time.Sleep(time.Millisecond)}func main(){    // channelDemo()    // bufferedChannel()   //缓冲区在提升性能上是有帮助的       channelClose()}</code></pre><h4 id="使用channel等待goroutine结束：">使用channel等待goroutine结束：</h4><pre><code class="language-go">import (       &quot;fmt&quot;    &quot;sync&quot;)func doWork(id int , c chan int , wg *sync.WaitGroup) {    for n := range c{        fmt.Printf(&quot;Worker %d receive %c\n&quot;,id,n)        wg.Done()       }}type worker struct {    in chan int    wg *sync.WaitGroup}func createWorker(id int, wg *sync.WaitGroup) worker {    w := worker{        in: make(chan int),        wg: wg,    }    go doWork(id, w.in , wg)    return w}func channelDemo(){    var wg sync.WaitGroup     //等待多人完成任务    var workers [10] worker    for i := 0; i&lt;10 ; i++{        workers [i] = createWorker(i,&amp;wg)    }    wg.Add(20)    for i, worker := range  workers{        worker.in &lt;- 'A'+i    }    for i ,worker := range workers{        worker.in &lt;- 'a'+i    }    wg.Wait()       //wait for all of them    //time.Sleep(time.Millisecond)}func main(){    channelDemo()}</code></pre><h4 id="使用channel实现树的遍历：">使用channel实现树的遍历：</h4><pre><code class="language-go">func (node *Node)TraverseWithChannel() chan *Node{//channel里面一个一个节点去收    out := make(chan *Node)    go func() {        node.TraverseFunc(func(node *Node) {            out &lt;- node        })        close(out)    }()    return out}</code></pre><h3 id="select">select  :</h3><p>👊select 是 Go 中的一个控制结构，类似于用于通信的 switch 语句。每个 case 必须是一个通信操作，要么是发送要么是接收。</p><p>👊select 随机执行一个可运行的 case。如果没有 case 可运行，它将阻塞，直到有 case 可运行。一个默认的子句应该总是可运行的。</p><pre><code class="language-go">func generator() chan int{    out := make(chan int)    go func() {        i := 0        for{            time.Sleep(time.Duration(rand.Intn(1500))*                       time.Millisecond)            out &lt;- i            i++        }    }()    return out}func main() {    var c1, c2 = generator(),generator()    for {        select { //非阻塞            case n := &lt;-c1:            fmt.Println(&quot;Receive from c1:&quot;, n)            case n := &lt;-c2:            fmt.Println(&quot;Receive from c2:&quot;, n)        }    }}</code></pre><p>程序输出结果：</p><p><img src="/2019/11/27/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/selectTest.png" srcset="undefined" alt="selectTest"></p><h3 id="传统同步机制：">传统同步机制：</h3><p><strong>WaitGroup</strong></p><p><strong>Mutex (互斥量)</strong></p><p><strong>Cond</strong></p><p>以Mutex为例：</p><pre><code class="language-go">type atomicInt struct {    value int    lock sync.Mutex//系统提供原子化操作，加入锁，实现原子化的int}func (a *atomicInt) increment(){    fmt.Println(&quot;safe increment&quot;)    func(){        a.lock.Lock()        defer a.lock.Unlock()        a.value++       }()}func(a *atomicInt) get() int{    a.lock.Lock()    defer a.lock.Unlock()    return a.value}func main() {    var a atomicInt    a.increment()    go func() {        a.increment()    }()     time.Sleep(time.Millisecond)    fmt.Println(a.get())//引入锁机制之后，DATA RACE没有了}</code></pre><p><img src="/2019/11/27/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/Mutex%E9%94%81.png" srcset="undefined" alt="Mutex锁"></p><hr><h2 id="day06">##Day06  :</h2><h3 id="http标准库-：">http标准库  ：</h3><p>⬛️使用http客户端发送请求；</p><p>⬛️使用http.Client控制请求头；</p><p>⬛️使用httputil简化工作；</p><pre><code class="language-go">func main() {    request, err := http.NewRequest(http.MethodGet,&quot;http://www.klayhu.github.io&quot;, nil)      request.Header.Add(&quot;User-Agent&quot;,&quot;Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1&quot;)    client := http.Client{        //如果没有请求头就不需要再次重定向        CheckRedirect: func(req *http.Request,                            via []*http.Request)        error {            //重定向的路径都在via里，每次的目标都在request里面，如果返回错误就会终止重定向  ---见源码            fmt.Println(&quot;Redirect:&quot;,req)            return nil        },    }    resp , err := client.Do(request)    if err != nil{        panic(err)    }    defer resp.Body.Close()    s, err := httputil.DumpResponse(resp, true)    if err != nil{        panic(err)    }    fmt.Printf(&quot;%s\n&quot;,s)}</code></pre><p><img src="/2019/11/27/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/%E4%BA%A4%E7%94%B1%E7%B3%BB%E7%BB%9F%E9%87%8D%E5%AE%9A%E5%90%91%E6%89%93%E5%8D%B0%E7%BB%93%E6%9E%9C.png" srcset="undefined" alt="交由系统重定向打印结果"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解Java虚拟机学习笔记（二）</title>
    <link href="undefined2019/11/25/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>2019/11/25/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="day02">Day02</h2><h3 id="第六章-类文件结构">第六章  类文件结构</h3><h4 id="6-3-class类文件的结构">6.3  Class类文件的结构</h4><p>🔽Class文件是一组以8位字节为基础的二进制流，各个数据项目严格按照顺序紧凑地排列在Class文件中，中间没有任何分隔符，这使得整个Class文件中储存的内容几乎都是程序运行的必要数据，没有空隙存在。当遇到需要占用8个字节以上空间的数据项时，会按照高位在前的方式分割成若干个8位字节进行存储。</p><p>根据Java虚拟机规范的规定，Class文件格式采用一种类似C语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：无符号数和表，后面的解析都要与这两种数据类型为基础。</p><p>↘️其中：</p><p>无符号数属于基本的数据类型，以u1、u2、u4、u8来表示1个字节、2个字节、4个字节、8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8构成字符串值。</p><p>表是有多个无符号数或者其他表作为数据项构成的符合数据类型，所有表都习惯性地以“_info”结尾。表用于描述有层次关系的复合结构的数据，整个Class文件本质上就是一张表，如下图所示。</p><p><img src="/2019/11/25/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/Class%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.png" srcset="undefined" alt="Class文件结构"></p><h5 id="6-3-1魔数与class文件的版本">6.3.1魔数与Class文件的版本</h5><p>每个Class文件的头4个字节称为魔数(Magic Number)，它的唯一作用是确定这个文件是否为一个能被虚拟机接受的Class文件。紧接着魔数的4字节存储的是Class文件的版本号，Java的版本号是从45开始的。</p><h5 id="6-3-2常量池">6.3.2常量池</h5><p>⛅️紧接着主次版本号之后的是常量池入口，常量池可以理解为Class文件之中的资源仓库，它是Class文件结构与其他项目关联最多的数据类型，也是占用Class文件空间最大的数据项目之一，同时它还是Class文件中第一个出现的表类型数据项目。</p><p>🕶由于常量池中常量的数量不是固定的，所以在常量池入口需要放置一项u2类型的数据，代表常量池容量计数值(constant_pool_count)。与Java语言习惯不一样的是，这个容量计数器是从1而不是0开始的。常量池容量为十六进制数0x0016，即十进制的22，代表常量池中有21项常量，索引范围为1-21。Class文件结构中只有常量池的容量计数是从1开始，对于其他集合类型，包括接口索引集合、字段表集合、方法表集合等的容量计数都与一般习惯相同，从0开始。</p><p>常量池中主要存放两大类常量：<strong>字面量</strong>(Literal)和<strong>符号引用</strong>(Symbolic Reference)。字面量，如文本字符串、声明为final的常量值等。而符号引用则属于编译原理方面的概念，包括了下面三种常量：</p><p><strong>1、类和接口的全限定名；</strong></p><p><strong>2、字段的名称和描述符；</strong></p><p><strong>3、方法的名称和描述符；</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>JavaVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go语言学习笔记（二）</title>
    <link href="undefined2019/11/25/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>2019/11/25/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h3 id="day03">##Day03  :</h3><h4 id="结构体和方法：">结构体和方法：</h4><p>🔌面向对象：go语言仅支持封装，不支持继承和多态</p><h5 id="结构的定义：">结构的定义：</h5><pre><code class="language-go">type TreeNode struct {    Left, Right *TreeNode    Value int}//切片定义nodes := []treeNode{{value:3},{},{6,nil,&amp;root},}</code></pre><p>为结构定义方法：</p><pre><code class="language-go">func (node treeNode) print(){    fmt.Println(node.value)}</code></pre><p>☑️Go语言虽然没有构造函数一说，但是可以通过工厂函数来控制。</p><pre><code class="language-go">func createNode(value int) *treeNode{    return &amp;treeNode{value:value}}</code></pre><h5 id="使用指针作为方法接收者：">使用指针作为方法接收者：</h5><pre><code class="language-go">func (node *treeNode)setValue(value int){    node.value=value}</code></pre><p>⚠️由于结构体是值传递，不存在引用传递。所以只有使用指针才可以改变结构内容。另：nil指针也可以调用方法。</p><h5 id="遍历结构函数：">遍历结构函数：</h5><p>接上述代码。定义一个树结构，并向其各个节点赋值：</p><pre><code class="language-go">    var root treeNode    root = treeNode{value:3}    root.left = &amp;treeNode{}    root.right = &amp;treeNode{5,nil,nil}    root.right.left = new(treeNode)    root.left.right = createNode(2)    root.right.left.setValue(4)</code></pre><p>中序遍历结构方法：</p><pre><code class="language-go">func (node *treeNode)Traverse(){//定义一个Traverse函数，函数接收者是指针类型的一个nodeif node == nil{return   }   node.left.Traverse()node.print()node.right.Traverse()}</code></pre><p><img src="/2019/11/25/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E7%BB%93%E6%9E%84%E5%87%BD%E6%95%B0%E6%89%93%E5%8D%B0%E7%BB%93%E6%9E%9C" srcset="undefined" alt="中序遍历结构函数打印结果"></p><hr><h4 id="包和封装：">包和封装：</h4><h5 id="定义：">定义：</h5><p>首字母大写：public</p><p>首字母小写：private</p><p>⚠️<strong>为一个结构定义的方法需要在同一个包内</strong></p><p>后序遍历结构函数：</p><pre><code class="language-go">type myTreeNode struct {    node *tree.Node}func (myNode *myTreeNode) postOrder(){//定义一个postOrder()函数，函数接收者是一个指针类型的myNode    if myNode == nil || myNode.node == nil{        return       }       //左右子树节点初始化    left := myTreeNode{myNode.node.Left}    left.postOrder()    right := myTreeNode{myNode.node.Right}    right.postOrder()    myNode.node.Print()}</code></pre><p><img src="/2019/11/25/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E7%BB%93%E6%9E%84%E5%87%BD%E6%95%B0%E6%89%93%E5%8D%B0%E7%BB%93%E6%9E%9C" srcset="undefined" alt="后序遍历结构函数打印结果"></p><hr><h4 id="接口：">接口：</h4><h5 id="接口定义：">接口定义：</h5><pre><code class="language-go">type Retriever interface {    Get(url string) string}func download (r Retriever) string{    return r.Get(&quot;http://www.baidu.com&quot;)}</code></pre><p>🦆“duck typing” 接口实现是隐式的，只要实现接口里的方法就行。</p><h5 id="接口的组合：">接口的组合：</h5><p>一个接口中可以整合其他接口或者方法</p><pre><code class="language-go">type RetrieverPoster interface {    Retriever    Poster    Connect(host string)}func session(r RetrieverPoster){    r.Get()    r.setValue()}</code></pre><hr><h4 id="函数式编程：">函数式编程：</h4><p>举例：</p><pre><code class="language-go">func adder() func(int)int{//定义adder()函数，类型是带有一个int参数，返回值是int的函数    sun := 0    return func (v int)int{        sun += v        return sun    }}func main(){    a := adder()    for i := 0; i &lt; 10; i++{        fmt.Println(a(i))    }}</code></pre><p>使用函数方法来遍历二叉树：</p><pre><code class="language-go">//重新定义一个遍历函数，与之前定义的Traverse函数不同，这里的TraverseFunc函数带有的参数是一个结构函数func (node *Node) TraverseFunc(f func(*Node)){    if node == nil{        return       }    node.Left.TraverseFunc(f)//这里f就是带有一个*Node参数的结构函数    f(node)    node.Right.TraverseFunc(f)}//修改后的遍历函数func (node *Node) Traverse(){node.TraverseFunc(func (n *Node){   //在函数体里调用重新定义好的函数n.Print()})}</code></pre><p>🕶至此，相较于定义函数来遍历二叉树，函数方法可以干的事情就更多了，而不局限于运行写好的函数体内容。</p><pre><code class="language-go">//在main()函数里可以添加节点计数器，直接调用重新定义的函数就可以了，十分简便！nodeCount := 0root.TraverseFunc(func (*tree.Node){    nodeCount ++})fmt.Println(&quot;nodeConut:&quot;,nodeCount)</code></pre><hr><h3 id="day04">##Day04  :</h3><h5 id="defer调用-：">defer调用  ：</h5><p>🌓defer关键字有几个特点：</p><p>*<strong>确保调用在函数结束时发生</strong></p><p>*<strong>参数在defer语句时计算</strong></p><p>*<strong>defer列表为先进后出</strong></p><pre><code class="language-go">//确保调用在函数结束时发生file,err := os.Create(filename) if err != nil{   panic(err)   }defer file.Close()  writer := bufio.NewWriter(file) defer writer.Flush()</code></pre><pre><code class="language-go">func tryDefer(){    for i := 0 ;i &lt; 100; i++{        defer fmt.Println(i)        if i==30{            panic (&quot;print too many!&quot;)        }       }}func main(){    tryDefer()}</code></pre><p><img src="/2019/11/25/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/%E5%8F%82%E6%95%B0%E5%9C%A8defer%E8%AF%AD%E5%8F%A5%E6%97%B6%E8%AE%A1%E7%AE%97" srcset="undefined" alt="参数在defer语句时计算"></p><p>对于错误处理要看文档</p><h5 id="panic">panic  :</h5><p>*<strong>停止当前函数执行</strong></p><p>*<strong>一直向上返回，执行每一层的defer</strong></p><p>*<strong>如果没有遇见recover，程序退出</strong></p><p>⏬</p><h5 id="recover">recover  :</h5><p>*<strong>仅在defer调用中使用</strong></p><p>*<strong>获取panic的值</strong></p><p>*<strong>如果无法处理，可重新panic</strong></p><pre><code class="language-go">func tryRecover(){   defer func(){    //匿名函数，只用写函数体    r := recover()    if err,ok := r.(error);ok{        fmt.Println(&quot;Error occurred&quot;,err)    }else {        panic(fmt.Sprintf(&quot;I dont know what to do : %v&quot;,r))    }   }()          //匿名函数所带参数        panic(errors.New(&quot;This is an error&quot;))                  //a := 5/5                     //fmt.Println(a)                  panic(123)                 }func main() {    tryRecover()} </code></pre><p><img src="/2019/11/25/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/panic&amp;recover" srcset="undefined" alt="panic&amp;amp;recover"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解Java虚拟机学习笔记</title>
    <link href="undefined2019/11/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>2019/11/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="day01">Day01</h2><h3 id="第2章-java内存区域与内存溢出异常">第2章  Java内存区域与内存溢出异常</h3><h4 id="2-2-运行时数据区域">2.2  运行时数据区域</h4><h5 id="2-2-1-程序计数器">2.2.1  程序计数器</h5><p>▶️字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。分支、循环、跳转、异常处理、线程恢复等基础功能都需要这个计数器完成。</p><h5 id="2-2-2-虚拟机栈">2.2.2  虚拟机栈</h5><p>▶️是线程私有的，它的生命周期与线程相同，其描述的是Java方法执行的内存模型。每个方法执行时都会创建一个“栈帧”，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用到执行完成的过程，就对应着一个虚拟机栈的入栈出栈的过程。 <em>(:з」∠)</em>_</p><p>局部变量表存放了各种基本数据类型、对象引用。64位长度的long和double占用2个局部变量空间(Slot)，其余类型只占用1个。</p><p><strong>在Java虚拟机规范中，对这个区域规定了两种异常情况：</strong></p><p>1、如果线程请求的栈深度大于虚拟机所允许的深度，将抛出<strong>StackOverflowError</strong>异常；</p><p>2、如果虚拟机栈可以动态扩展，扩展时无法申请到足够的内存，就会抛出<strong>OutOfMemoryError</strong>异常；</p><h5 id="2-2-3-本地方法栈">2.2.3  本地方法栈</h5><p>为虚拟机使用到的native方法服务。也会抛上述两种异常。</p><h5 id="2-2-4-java堆">2.2.4  Java堆</h5><p>▶️Java堆是被所有线程共享的一块内存区域，在虚拟机创建时启动。存放对象实例，也是垃圾收集器管理的主要区域。如果堆中没有内存完成实例分配，并且堆也无法再扩展时，会抛出<strong>OutOfMemoryError</strong>异常。</p><p>✒️分配内存：</p><p><code>if(内存归整){</code></p><p><code>用过的内存放一边，没用的在另一边，内存写入时，移动分界点位置的指针，完成内存分配。---指针碰撞</code></p><p><code>}</code></p><p><code>if(内存不归整){</code></p><p><code>维护一个列表，记录哪些内存块是可用的，分配的时候找一块足够大的空间分划给对象，并更新表上的记录。---空闲列表</code></p><p><code>}</code></p><h5 id="2-2-5-方法区">2.2.5  方法区</h5><p>▶️存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p><p>当方法区无法满足内存分配时，会抛出<strong>OutOfMemoryError</strong>异常。</p><h5 id="2-2-6-运行时常量池">2.2.6  运行时常量池</h5><p>▶️是方法区的一部分，字面量和符号引用在类加载后进入方法区的运行时常量池中存放，具有动态性。在常量池无法申请到内存时会抛出<strong>OutOfMemoryError</strong>异常。</p><h4 id="2-3-hotspot虚拟机对象探秘">2.3  HotSpot虚拟机对象探秘</h4><h5 id="2-3-1-对象的创建">2.3.1  对象的创建</h5><p>▶️虚拟机遇到new指令时，首先检查指令的参数是否能在常量池中定位到一个类的符号引用，并检查这个符号是否已被加载、解析和初始化过，如果没有，就先执行类加载过程。-&gt;通过检查后，分配内存（<strong>指针碰撞、空闲列表</strong>）。</p><h5 id="2-3-2-对象的内存布局">2.3.2  对象的内存布局</h5><p>对象在内存中存储的布局分为3块区域：对象头、实例数据和对齐填充。</p><h5 id="2-3-3-对象的访问定位">2.3.3  对象的访问定位</h5><p>Java程序通过栈上的reference数据来操作堆上的具体对象。对象的访问方式目前主流的方式是使用句柄和直接指针两种。</p><p>☑️<strong>使用句柄访问</strong></p><p>Java堆中会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体信息。</p><p><img src="/2019/11/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%80%9A%E8%BF%87%E5%8F%A5%E6%9F%84%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1.png" srcset="undefined" alt="通过句柄访问对象"></p><p>☑️<strong>直接指针访问</strong></p><p>Java堆中的布局就必须考虑如何放置访问类型数据的相关信息。而reference中存储的直接就是对象地址。</p><p><img src="/2019/11/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%80%9A%E8%BF%87%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1.png" srcset="undefined" alt="通过直接指针访问对象"></p><hr><h3 id="第3章-垃圾收集器与内存分配策略">第3章  垃圾收集器与内存分配策略</h3><h4 id="3-1-对象已死吗">3.1  对象已死吗</h4><h5 id="3-2-1引用计数算法">3.2.1引用计数算法</h5><p>▶️给对象中添加一个引用计数器，每当有一个地方引用它时，计数器就加1；当引用失效时，计数器就减1。任何时刻计数器为零的对象就是不可能再被使用的。该算法存在缺陷，并不是虚拟机来判断对象是否存活的方法。</p><h5 id="3-2-2-可达性分析算法">3.2.2  可达性分析算法</h5><p>▶️算法基本思路是通过一系列称为 “GC Root” 的对象作为起始点，从这些节点向下搜索，搜索走过的路就是通过一系列称为引用链，当一个对象到GC Root没有任何引用链相连（对象不可达），则证明此对象是不可用的，需要被回收。</p><h5 id="3-2-3-再谈引用">3.2.3  再谈引用</h5><p>JDK1.2之后，Java对引用的概念进行了扩充。分为强引用、软引用、弱引用、虚引用。</p><p>🥇<strong>□强引用</strong></p><p>代码中普遍存在，类似<code>Object obj = new Object()</code>，只要强引用存在，垃圾收集器永远不会回收掉被引用的对象。</p><p>🥈<strong>□软引用</strong></p><p>描述一些还有用但是非必须的对象。系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常，在1.2之后，提供了SoftReference类来实现软引用。</p><p>🥉<strong>□弱引用</strong></p><p>也是用来描述非必须的对象，被弱引用关联的对象智能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否够用，都会回收掉只被弱引用关联的对象。1.2之后提供了WeakReference类实现弱引用。</p><p>✴️<strong>□虚引用</strong></p><h5 id="3-2-4-生存还是死亡">3.2.4  生存还是死亡</h5><p>关于finalize()方法，对象在被回收前会对自己进行一次自救。</p><h4 id="3-4-hotspot的算法实现">3.4  HotSpot的算法实现</h4><h5 id="3-4-1-枚举根节点">3.4.1  枚举根节点</h5><p>挨个通过GC Root寻找引用链，存在系统停顿。</p><h5 id="3-4-2-安全点">3.4.2  安全点</h5><p>。。。。。。。。。。。。</p><h5 id="3-4-3-安全区域">3.4.3  安全区域</h5><p>安全区域指在一段代码片段中，引用关系不会发生改变，在这个区域中的任意地方开始GC都是安全的。也可以把Safe Region 看做是被扩展了的Safepoint。</p><h4 id="3-5-垃圾收集器-з">3.5  垃圾收集器       <em>(:з」∠)</em>_</h4><h5 id="3-5-1-serial收集器">3.5.1  Serial收集器</h5><p>✒️Serial收集器是最基本、发展历史最久的收集器。单线程，而且在收集工作进行时必须暂停其他所有工作线程，直到收集结束。但是简单高效，运行在新生代垃圾收集的区域，对于在Client模式下的虚拟机来说是一个很好的选择。</p><h5 id="3-5-2-parnew收集器">3.5.2  ParNew收集器</h5><p>✒️ParNew收集器是多线程版本的Serial收集器。在控制参数、收集算法、Stop The World、对象分配规则、回售策略与Serial收集器相同。适合Server模式的新生代收集器。目前，除了Serial收集器，只有ParNew收集器可以跟CMS收集器配合。</p><h5 id="3-5-3-parallel-scavenge收集器">3.5.3  Parallel Scavenge收集器</h5><p>✒️新生代复制算法收集器。侧重点在达到一个可控制的吞吐量（CPU运行用户代码所耗时间/CPU消耗总时间）。</p><h5 id="3-5-4-serial-old收集器">3.5.4  Serial Old收集器</h5><p>✒️是Serial老年代的版本。单线程，使用标记-整理算法。适合Client模式下的虚拟机，但如果在Server模式下，还有两大用途：在JDK1.5以前的版本中与Parallel Scavcenge收集器搭配使用；另一种就是CMS的后备预案</p>]]></content>
    
    
    
    <tags>
      
      <tag>JavaVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go语言学习笔记</title>
    <link href="undefined2019/11/21/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>2019/11/21/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="go语言学习笔记">Go语言学习笔记</h2><h3 id="day01-：">##Day01  ：</h3><h4 id="函数：">函数：</h4><h5 id="函数的定义">函数的定义:</h5><p>**·**func xxx(函数名)（携带的参数）函数的返回值{</p><p>/*      函数体      */</p><p>}</p><p>eg:</p><p><code>func minus(a,b int , op string ) int{}</code></p><p><code>func div(c,d int)(int,int){}</code></p><p><code>func multiply(e,f int)(g,h int){}</code></p><p><strong>·</strong>▶️作为函数式编程的语言，在Go语言中一个函数可以有多个返回值，在声明返回值的<code>return</code>语句中多个返回值中间用<code>,</code>隔开。</p><p><strong>·</strong>▶️如果在定义函数返回值时不想使用某个参数，在参数位上输入<code>_</code>下划线即可</p><p><strong>·</strong>🏴函数式编程规范：</p><p><code>func apply(func op(int , int) int , a , b int )int{</code></p><p><strong>·</strong>⏫解析：在apply函数中传入的参数是op这个函数和a,b两个int类型的变量，op函数返回值是int，自带两个int类型参数。</p><p><strong>·</strong>🛰定义一个参数列表：</p><pre><code class="language-go">func sum(numbers ...int) int{    s :=0   for i := range numbers{        s+= numbers[i]       }    return s}</code></pre><hr><h4 id="指针：">指针：</h4><p>⚡️Go语言指针没有运算，只存在值传递</p><h5 id="指针的定义：">指针的定义：</h5><p><code>var a int =3</code></p><p><code>var pa *int = &amp;a</code></p><p><code>*pa = 3</code></p><p><code>fmt.Println(*pa,pa)</code></p><p>▶️打印结果是:3  0xc000000a088</p><p>但是多次运行发现打印的地址都不一样，这与初始化内存空间有关。</p><p>指针值传递代码</p><p><code>func swap(a,s *int)(int,int){</code></p><p>​<code>*s,*a = *a,*s</code></p><p><code>}</code></p><p><code>func main(){</code></p><p>​<code>a:=3,s:=5</code></p><p>​<code>swap(&amp;a,&amp;s)</code></p><p>​<code>fmt.Println(a,s)</code></p><p><code>}</code></p><p><strong>·</strong>☑️打印结果是：5 , 3</p><hr><h4 id="数组">数组</h4><p>func f(arr[5]int){</p><p>//函数体</p><p>}</p><p><strong>·</strong>🥊数组是值类型，调用该函数相当于拷贝。可以用指针数组传值。</p><h5 id="数组的定义：">数组的定义：</h5><p><code>var array1 [5] int</code></p><p><code>array2:= [3]int {1,2,3}</code></p><p><code>array3:=[...]int{1,2,3,4,5}</code></p><p><code>var grid [4][5] bool</code></p><p>数组遍历：</p><p><code>for i:=0;i&lt;len(arr2);i+{</code></p><p><code>fmt.Println(arr2[i])</code></p><p><code>}</code></p><p><code>for i,r:= range arr1{//i：下标；r：数值；</code></p><p>​<code>fmt.Println(i,r)</code></p><p><code>}</code></p><hr><h3 id="day02-：">##Day02  ：</h3><h4 id="切片：">切片：</h4><h5 id="切片的定义：">切片的定义：</h5><pre><code class="language-go">var s []int  //zero value for slice is nil</code></pre><p>eg:</p><pre><code class="language-go">arr := [...]int{0,1,2,3,4,5,6,7}fmt.Println(&quot;arr[2:6] =&quot;,arr[2:6])fmt.Println(&quot;arr[:6] =&quot;,arr[:6])s1 := arr[2:]fmt.Println(&quot;arr[2:]&quot;, s1)s2 := arr[:]fmt.Println(&quot;arr[:] =&quot;, s2)</code></pre><p>⏬<strong>Slice本身没有数据，是对底层array的一个view</strong>，其中Slice本身有一个数据结构 :</p><pre><code class="language-go">func updateSlice(s []int){//定义一个updateSlice函数,观察Slice的打印结果s[0]=100}fmt.Println(&quot;updateSlice s1:&quot;)updateSlice(s1)fmt.Println(s1)fmt.Println(arr)fmt.Println(&quot;updateSlice s2:&quot;)updateSlice(s2)fmt.Println(s2)fmt.Println(arr)</code></pre><p><img src="/2019/11/21/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C1.png" srcset="undefined" alt="运行结果1"></p><p>可以看出，Slice不是值类型的。</p><p><strong>ReSlice</strong></p><pre><code class="language-go">fmt.Println(&quot;ReSlice: &quot;)arr[0],arr[2]=0,2//先把元素赋值回来s1=arr[2:6]s2=s1[3:5]fmt.Println(s1)fmt.Println(s2)</code></pre><p><img src="/2019/11/21/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C2.png" srcset="undefined" alt="运行结果2"></p><p>⚠️<strong>注意：Slice可以向前扩展，不可以向后扩展，Slice底层有两个参数：len(长度)、cap(容量)</strong></p><p>Slice底层</p><p><img src="/2019/11/21/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Slice%E5%BA%95%E5%B1%82.png" srcset="undefined" alt="Slice底层"></p><p>ReSlice底层</p><p><img src="/2019/11/21/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ReSlice%E5%BA%95%E5%B1%82.png" srcset="undefined" alt="ReSlice底层"></p><h5 id="切片的使用">切片的使用</h5><pre><code class="language-go">func printslice(s []int){    fmt.Printf(&quot;%v,len=%d,cap=%d\n&quot;,s,len(s),cap(s))}</code></pre><p>🔼定义了一个用于打印切片元素信息的函数</p><p>🌳从中部删除切片中的元素：</p><pre><code class="language-go">fmt.Println(&quot;Deleting elements from slice&quot;)s2=append(s2[:3],s2[4:]...)printslice(s2)</code></pre><p>🌳从切片头部删除元素：</p><pre><code class="language-go">fmt.Println(&quot;Popping from front&quot;)front := s2[0]s2 = s2[1:]fmt.Println(front)printslice(s2)</code></pre><p>🌳从切片尾部删除元素：</p><pre><code class="language-go">fmt.Println(&quot;Popping from back&quot;)tail := s2[len(s2) -1]s2 = s2[:len(s2)-1]fmt.Println(tail)printslice(s2)</code></pre><hr><h4 id="map">Map :</h4><h5 id="map的创建：">Map的创建：</h5><pre><code class="language-go">m := map[string]string{    &quot;name&quot;: &quot;kalyhu&quot;,    &quot;course&quot;: &quot;golang&quot;,    &quot;site&quot;: &quot;Bilibili&quot;,    &quot;quality&quot;: &quot;notBad&quot;}//mapK[V],map[K1]map[K2]V</code></pre><h5 id="map的操作：">Map的操作：</h5><p>创建：<code>make map[string]int</code></p><p>获取元素：<code>m[key]</code></p><p>通过使用<code>value,ok :=m[key]</code>来判断是否存在key</p><pre><code class="language-go">fmt.Println(&quot;Getting values&quot;)courseName , ok:= m[&quot;course&quot;]fmt.Println(courseName,ok)if courseName,ok := m[&quot;couse&quot;];ok{    fmt.Println(courseName)}else {     fmt.Println(&quot;key does not exist !&quot;)}fmt.Println(&quot;Deleting values&quot;)name , ok := m[&quot;name&quot;]fmt.Println(name,ok)delete(m,&quot;name&quot;)//由于key：name被删掉了，下面的ok将会打印出falsename , ok = m[&quot;name&quot;]fmt.Println(name,ok)</code></pre><p><img src="/2019/11/21/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Map%E7%9A%84%E6%93%8D%E4%BD%9C.png" srcset="undefined" alt="Map的操作"></p><p>☑️遍历Map</p><p>使用range遍历key，或者遍历key，value对。但不保证遍历顺序，如要顺序需手动对key排序。</p><hr><h4 id="字符和字符串处理：">字符和字符串处理：</h4><p>字符：rune  (int32)、byte(uint8)   字符串：string</p><pre><code class="language-go">s := &quot;你好，Go语言!&quot;fmt.Println(s)for _,b := range []byte(s){    fmt.Printf(&quot;%X &quot;,b)}fmt.Println()for i,ch := range s{//ch is a rune       fmt.Printf(&quot;(%d,%X) &quot;,i,ch)}fmt.Println()</code></pre><p><img src="/2019/11/21/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%89%93%E5%8D%B0%E7%BB%93%E6%9E%9C.png" srcset="undefined" alt="字符串打印结果"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Github的第一篇博客</title>
    <link href="undefined2019/11/21/Github%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
    <url>2019/11/21/Github%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<p>写博客总是能让我静心，来Github上我就选择不记录技术以外的生活，相较于博客园我会记录一些debug过程，Github对我来说作为托管代码、学习源码和记录学习过程的平台更要学会利用、经营。坚持写博客另一方面也是为今后写文档培养意识和兴趣。</p><p>附上一张昨晚拍的夕阳！🥂</p><p><img src="/2019/11/21/Github%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/image1.jpg" srcset="undefined" alt></p><p>Stay hungry. Stay foolish.</p>]]></content>
    
    
    
    <tags>
      
      <tag>Github</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>