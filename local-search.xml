<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>深入理解Java虚拟机学习笔记</title>
    <link href="undefined2019/11/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>2019/11/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="day01">Day01</h2><h3 id="第2章-java内存区域与内存溢出异常">第2章  Java内存区域与内存溢出异常</h3><h4 id="2-2-运行时数据区域">2.2  运行时数据区域</h4><h5 id="2-2-1-程序计数器">2.2.1  程序计数器</h5><p>▶️字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。分支、循环、跳转、异常处理、线程恢复等基础功能都需要这个计数器完成。</p><h5 id="2-2-2-虚拟机栈">2.2.2  虚拟机栈</h5><p>▶️是线程私有的，它的生命周期与线程相同，其描述的是Java方法执行的内存模型。每个方法执行时都会创建一个“栈帧”，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用到执行完成的过程，就对应着一个虚拟机栈的入栈出栈的过程。 <em>(:з」∠)</em>_</p><p>局部变量表存放了各种基本数据类型、对象引用。64位长度的long和double占用2个局部变量空间(Slot)，其余类型只占用1个。</p><p><strong>在Java虚拟机规范中，对这个区域规定了两种异常情况：</strong></p><p>1、如果线程请求的栈深度大于虚拟机所允许的深度，将抛出<strong>StackOverflowError</strong>异常；</p><p>2、如果虚拟机栈可以动态扩展，扩展时无法申请到足够的内存，就会抛出<strong>OutOfMemoryError</strong>异常；</p><h5 id="2-2-3-本地方法栈">2.2.3  本地方法栈</h5><p>为虚拟机使用到的native方法服务。也会抛上述两种异常。</p><h5 id="2-2-4-java堆">2.2.4  Java堆</h5><p>▶️Java堆是被所有线程共享的一块内存区域，在虚拟机创建时启动。存放对象实例，也是垃圾收集器管理的主要区域。如果堆中没有内存完成实例分配，并且堆也无法再扩展时，会抛出<strong>OutOfMemoryError</strong>异常。</p><p>✒️分配内存：</p><p><code>if(内存归整){</code></p><p><code>用过的内存放一边，没用的在另一边，内存写入时，移动分界点位置的指针，完成内存分配。---指针碰撞</code></p><p><code>}</code></p><p><code>if(内存不归整){</code></p><p><code>维护一个列表，记录哪些内存块是可用的，分配的时候找一块足够大的空间分划给对象，并更新表上的记录。---空闲列表</code></p><p><code>}</code></p><h5 id="2-2-5-方法区">2.2.5  方法区</h5><p>▶️存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p><p>当方法区无法满足内存分配时，会抛出<strong>OutOfMemoryError</strong>异常。</p><h5 id="2-2-6-运行时常量池">2.2.6  运行时常量池</h5><p>▶️是方法区的一部分，字面量和符号引用在类加载后进入方法区的运行时常量池中存放，具有动态性。在常量池无法申请到内存时会抛出<strong>OutOfMemoryError</strong>异常。</p><h4 id="2-3-hotspot虚拟机对象探秘">2.3  HotSpot虚拟机对象探秘</h4><h5 id="2-3-1-对象的创建">2.3.1  对象的创建</h5><p>▶️虚拟机遇到new指令时，首先检查指令的参数是否能在常量池中定位到一个类的符号引用，并检查这个符号是否已被加载、解析和初始化过，如果没有，就先执行类加载过程。-&gt;通过检查后，分配内存（<strong>指针碰撞、空闲列表</strong>）。</p><h5 id="2-3-2-对象的内存布局">2.3.2  对象的内存布局</h5><p>对象在内存中存储的布局分为3块区域：对象头、实例数据和对齐填充。</p><h5 id="2-3-3-对象的访问定位">2.3.3  对象的访问定位</h5><p>Java程序通过栈上的reference数据来操作堆上的具体对象。对象的访问方式目前主流的方式是使用句柄和直接指针两种。</p><p>☑️<strong>使用句柄访问</strong></p><p>Java堆中会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体信息。</p><p><img src="/2019/11/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%80%9A%E8%BF%87%E5%8F%A5%E6%9F%84%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1.png" srcset="undefined" alt="通过句柄访问对象"></p><p>☑️<strong>直接指针访问</strong></p><p>Java堆中的布局就必须考虑如何放置访问类型数据的相关信息。而reference中存储的直接就是对象地址。</p><p><img src="/2019/11/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%80%9A%E8%BF%87%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1.png" srcset="undefined" alt="通过直接指针访问对象"></p><hr><h3 id="第3章-垃圾收集器与内存分配策略">第3章  垃圾收集器与内存分配策略</h3><h4 id="3-1-对象已死吗">3.1  对象已死吗</h4><h5 id="3-2-1引用计数算法">3.2.1引用计数算法</h5><p>▶️给对象中添加一个引用计数器，每当有一个地方引用它时，计数器就加1；当引用失效时，计数器就减1。任何时刻计数器为零的对象就是不可能再被使用的。该算法存在缺陷，并不是虚拟机来判断对象是否存活的方法。</p><h5 id="3-2-2-可达性分析算法">3.2.2  可达性分析算法</h5><p>▶️算法基本思路是通过一系列称为 “GC Root” 的对象作为起始点，从这些节点向下搜索，搜索走过的路就是通过一系列称为引用链，当一个对象到GC Root没有任何引用链相连（对象不可达），则证明此对象是不可用的，需要被回收。</p><h5 id="3-2-3-再谈引用">3.2.3  再谈引用</h5><p>JDK1.2之后，Java对引用的概念进行了扩充。分为强引用、软引用、弱引用、虚引用。</p><p>🥇<strong>□强引用</strong></p><p>代码中普遍存在，类似<code>Object obj = new Object()</code>，只要强引用存在，垃圾收集器永远不会回收掉被引用的对象。</p><p>🥈<strong>□软引用</strong></p><p>描述一些还有用但是非必须的对象。系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常，在1.2之后，提供了SoftReference类来实现软引用。</p><p>🥉<strong>□弱引用</strong></p><p>也是用来描述非必须的对象，被弱引用关联的对象智能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否够用，都会回收掉只被弱引用关联的对象。1.2之后提供了WeakReference类实现弱引用。</p><p>✴️<strong>□虚引用</strong></p><h5 id="3-2-4-生存还是死亡">3.2.4  生存还是死亡</h5><p>关于finalize()方法，对象在被回收前会对自己进行一次自救。</p><h4 id="3-4-hotspot的算法实现">3.4  HotSpot的算法实现</h4><h5 id="3-4-1-枚举根节点">3.4.1  枚举根节点</h5><p>挨个通过GC Root寻找引用链，存在系统停顿。</p><h5 id="3-4-2-安全点">3.4.2  安全点</h5><p>。。。。。。。。。。。。</p><h5 id="3-4-3-安全区域">3.4.3  安全区域</h5><p>安全区域指在一段代码片段中，引用关系不会发生改变，在这个区域中的任意地方开始GC都是安全的。也可以把Safe Region 看做是被扩展了的Safepoint。</p><h4 id="3-5-垃圾收集器-з">3.5  垃圾收集器       <em>(:з」∠)</em>_</h4><h5 id="3-5-1-serial收集器">3.5.1  Serial收集器</h5><p>✒️Serial收集器是最基本、发展历史最久的收集器。单线程，而且在收集工作进行时必须暂停其他所有工作线程，直到收集结束。但是简单高效，运行在新生代垃圾收集的区域，对于在Client模式下的虚拟机来说是一个很好的选择。</p><h5 id="3-5-2-parnew收集器">3.5.2  ParNew收集器</h5><p>✒️ParNew收集器是多线程版本的Serial收集器。在控制参数、收集算法、Stop The World、对象分配规则、回售策略与Serial收集器相同。适合Server模式的新生代收集器。目前，除了Serial收集器，只有ParNew收集器可以跟CMS收集器配合。</p><h5 id="3-5-3-parallel-scavenge收集器">3.5.3  Parallel Scavenge收集器</h5><p>✒️新生代复制算法收集器。侧重点在达到一个可控制的吞吐量（CPU运行用户代码所耗时间/CPU消耗总时间）。</p><h5 id="3-5-4-serial-old收集器">3.5.4  Serial Old收集器</h5><p>✒️是Serial老年代的版本。单线程，使用标记-整理算法。适合Client模式下的虚拟机，但如果在Server模式下，还有两大用途：在JDK1.5以前的版本中与Parallel Scavcenge收集器搭配使用；另一种就是CMS的后备预案</p>]]></content>
    
    
    
    <tags>
      
      <tag>JavaVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go语言学习笔记</title>
    <link href="undefined2019/11/21/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>2019/11/21/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="go语言学习笔记">Go语言学习笔记</h2><h3 id="day01-：">##Day01  ：</h3><h4 id="函数：">函数：</h4><h5 id="函数的定义">函数的定义:</h5><p>**·**func xxx(函数名)（携带的参数）函数的返回值{</p><p>/*      函数体      */</p><p>}</p><p>eg:</p><p><code>func minus(a,b int , op string ) int{}</code></p><p><code>func div(c,d int)(int,int){}</code></p><p><code>func multiply(e,f int)(g,h int){}</code></p><p><strong>·</strong>▶️作为函数式编程的语言，在Go语言中一个函数可以有多个返回值，在声明返回值的<code>return</code>语句中多个返回值中间用<code>,</code>隔开。</p><p><strong>·</strong>▶️如果在定义函数返回值时不想使用某个参数，在参数位上输入<code>_</code>下划线即可</p><p><strong>·</strong>🏴函数式编程规范：</p><p><code>func apply(func op(int , int) int , a , b int )int{</code></p><p><strong>·</strong>⏫解析：在apply函数中传入的参数是op这个函数和a,b两个int类型的变量，op函数返回值是int，自带两个int类型参数。</p><p><strong>·</strong>🛰定义一个参数列表：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(numbers ...<span class="keyword">int</span>)</span> <span class="title">int</span></span>&#123;</span><br><span class="line">    s :=<span class="number">0</span>   <span class="keyword">for</span> i := <span class="keyword">range</span> numbers&#123;</span><br><span class="line">        s+= numbers[i]   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="指针：">指针：</h4><p>⚡️Go语言指针没有运算，只存在值传递</p><h5 id="指针的定义：">指针的定义：</h5><p><code>var a int =3</code></p><p><code>var pa *int = &amp;a</code></p><p><code>*pa = 3</code></p><p><code>fmt.Println(*pa,pa)</code></p><p>▶️打印结果是:3  0xc000000a088</p><p>但是多次运行发现打印的地址都不一样，这与初始化内存空间有关。</p><p>指针值传递代码</p><p><code>func swap(a,s *int)(int,int){</code></p><p>​<code>*s,*a = *a,*s</code></p><p><code>}</code></p><p><code>func main(){</code></p><p>​<code>a:=3,s:=5</code></p><p>​<code>swap(&amp;a,&amp;s)</code></p><p>​<code>fmt.Println(a,s)</code></p><p><code>}</code></p><p><strong>·</strong>☑️打印结果是：5 , 3</p><hr><h4 id="数组">数组</h4><p>func f(arr[5]int){</p><p>//函数体</p><p>}</p><p><strong>·</strong>🥊数组是值类型，调用该函数相当于拷贝。可以用指针数组传值。</p><h5 id="数组的定义：">数组的定义：</h5><p><code>var array1 [5] int</code></p><p><code>array2:= [3]int {1,2,3}</code></p><p><code>array3:=[...]int{1,2,3,4,5}</code></p><p><code>var grid [4][5] bool</code></p><p>数组遍历：</p><p><code>for i:=0;i&lt;len(arr2);i+{</code></p><p><code>fmt.Println(arr2[i])</code></p><p><code>}</code></p><p><code>for i,r:= range arr1{//i：下标；r：数值；</code></p><p>​<code>fmt.Println(i,r)</code></p><p><code>}</code></p><hr><h3 id="day02-：">##Day02  ：</h3><h4 id="切片：">切片：</h4><h5 id="切片的定义：">切片的定义：</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s []<span class="keyword">int</span>  <span class="comment">//zero value for slice is nil</span></span><br></pre></td></tr></table></figure><p>eg:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">arr := [...]<span class="keyword">int</span>&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;</span><br><span class="line">fmt.Println(<span class="string">"arr[2:6] ="</span>,arr[<span class="number">2</span>:<span class="number">6</span>])</span><br><span class="line">fmt.Println(<span class="string">"arr[:6] ="</span>,arr[:<span class="number">6</span>])</span><br><span class="line">s1 := arr[<span class="number">2</span>:]</span><br><span class="line">fmt.Println(<span class="string">"arr[2:]"</span>, s1)</span><br><span class="line">s2 := arr[:]</span><br><span class="line">fmt.Println(<span class="string">"arr[:] ="</span>, s2)</span><br></pre></td></tr></table></figure><p>⏬<strong>Slice本身没有数据，是对底层array的一个view</strong>，其中Slice本身有一个数据结构 :</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">updateSlice</span><span class="params">(s []<span class="keyword">int</span>)</span></span>&#123;<span class="comment">//定义一个updateSlice函数,观察Slice的打印结果</span></span><br><span class="line">s[<span class="number">0</span>]=<span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"updateSlice s1:"</span>)</span><br><span class="line">updateSlice(s1)</span><br><span class="line">fmt.Println(s1)</span><br><span class="line">fmt.Println(arr)</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"updateSlice s2:"</span>)</span><br><span class="line">updateSlice(s2)</span><br><span class="line">fmt.Println(s2)</span><br><span class="line">fmt.Println(arr)</span><br></pre></td></tr></table></figure><p><img src="/2019/11/21/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C1.png" srcset="undefined" alt="运行结果1"></p><p>可以看出，Slice不是值类型的。</p><p><strong>ReSlice</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(<span class="string">"ReSlice: "</span>)</span><br><span class="line">arr[<span class="number">0</span>],arr[<span class="number">2</span>]=<span class="number">0</span>,<span class="number">2</span><span class="comment">//先把元素赋值回来</span></span><br><span class="line">s1=arr[<span class="number">2</span>:<span class="number">6</span>]</span><br><span class="line">s2=s1[<span class="number">3</span>:<span class="number">5</span>]</span><br><span class="line">fmt.Println(s1)</span><br><span class="line">fmt.Println(s2)</span><br></pre></td></tr></table></figure><p><img src="/2019/11/21/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C2.png" srcset="undefined" alt="运行结果2"></p><p>⚠️<strong>注意：Slice可以向前扩展，不可以向后扩展，Slice底层有两个参数：len(长度)、cap(容量)</strong></p><p>Slice底层</p><p><img src="/2019/11/21/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Slice%E5%BA%95%E5%B1%82.png" srcset="undefined" alt="Slice底层"></p><p>ReSlice底层</p><p><img src="/2019/11/21/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ReSlice%E5%BA%95%E5%B1%82.png" srcset="undefined" alt="ReSlice底层"></p><h5 id="切片的使用">切片的使用</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printslice</span><span class="params">(s []<span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">    fmt.Printf(<span class="string">"%v,len=%d,cap=%d\n"</span>,s,<span class="built_in">len</span>(s),<span class="built_in">cap</span>(s))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>🔼定义了一个用于打印切片元素信息的函数</p><p>🌳从中部删除切片中的元素：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(<span class="string">"Deleting elements from slice"</span>)</span><br><span class="line">s2=<span class="built_in">append</span>(s2[:<span class="number">3</span>],s2[<span class="number">4</span>:]...)</span><br><span class="line">printslice(s2)</span><br></pre></td></tr></table></figure><p>🌳从切片头部删除元素：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(<span class="string">"Popping from front"</span>)</span><br><span class="line">front := s2[<span class="number">0</span>]</span><br><span class="line">s2 = s2[<span class="number">1</span>:]</span><br><span class="line">fmt.Println(front)</span><br><span class="line">printslice(s2)</span><br></pre></td></tr></table></figure><p>🌳从切片尾部删除元素：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(<span class="string">"Popping from back"</span>)</span><br><span class="line">tail := s2[<span class="built_in">len</span>(s2) <span class="number">-1</span>]</span><br><span class="line">s2 = s2[:<span class="built_in">len</span>(s2)<span class="number">-1</span>]</span><br><span class="line">fmt.Println(tail)</span><br><span class="line">printslice(s2)</span><br></pre></td></tr></table></figure><hr><h4 id="map">Map :</h4><h5 id="map的创建：">Map的创建：</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"kalyhu"</span>,</span><br><span class="line">    <span class="string">"course"</span>: <span class="string">"golang"</span>,</span><br><span class="line">    <span class="string">"site"</span>: <span class="string">"Bilibili"</span>,</span><br><span class="line">    <span class="string">"quality"</span>: <span class="string">"notBad"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//mapK[V],map[K1]map[K2]V</span></span><br></pre></td></tr></table></figure><h5 id="map的操作：">Map的操作：</h5><p>创建：<code>make map[string]int</code></p><p>获取元素：<code>m[key]</code></p><p>通过使用<code>value,ok :=m[key]</code>来判断是否存在key</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(<span class="string">"Getting values"</span>)</span><br><span class="line">courseName , ok:= m[<span class="string">"course"</span>]</span><br><span class="line">fmt.Println(courseName,ok)</span><br><span class="line"><span class="keyword">if</span> courseName,ok := m[<span class="string">"couse"</span>];ok&#123;</span><br><span class="line">    fmt.Println(courseName)</span><br><span class="line">&#125;<span class="keyword">else</span> &#123; </span><br><span class="line">    fmt.Println(<span class="string">"key does not exist !"</span>)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"Deleting values"</span>)</span><br><span class="line">name , ok := m[<span class="string">"name"</span>]</span><br><span class="line">fmt.Println(name,ok)</span><br><span class="line"><span class="built_in">delete</span>(m,<span class="string">"name"</span>)</span><br><span class="line"><span class="comment">//由于key：name被删掉了，下面的ok将会打印出false</span></span><br><span class="line">name , ok = m[<span class="string">"name"</span>]</span><br><span class="line">fmt.Println(name,ok)</span><br></pre></td></tr></table></figure><p><img src="/2019/11/21/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Map%E7%9A%84%E6%93%8D%E4%BD%9C.png" srcset="undefined" alt="Map的操作"></p><p>☑️遍历Map</p><p>使用range遍历key，或者遍历key，value对。但不保证遍历顺序，如要顺序需手动对key排序。</p><hr><h4 id="字符和字符串处理：">字符和字符串处理：</h4><p>字符：rune  (int32)、byte(uint8)   字符串：string</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">"你好，Go语言!"</span></span><br><span class="line">fmt.Println(s)</span><br><span class="line"><span class="keyword">for</span> _,b := <span class="keyword">range</span> []<span class="keyword">byte</span>(s)&#123;</span><br><span class="line">    fmt.Printf(<span class="string">"%X "</span>,b)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println()</span><br><span class="line"><span class="keyword">for</span> i,ch := <span class="keyword">range</span> s&#123;<span class="comment">//ch is a rune   </span></span><br><span class="line">    fmt.Printf(<span class="string">"(%d,%X) "</span>,i,ch)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println()</span><br></pre></td></tr></table></figure><p><img src="/2019/11/21/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%89%93%E5%8D%B0%E7%BB%93%E6%9E%9C.png" srcset="undefined" alt="字符串打印结果"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Github的第一篇博客</title>
    <link href="undefined2019/11/21/Github%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
    <url>2019/11/21/Github%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<p>写博客总是能让我静心，来Github上我就选择不记录技术以外的生活，相较于博客园我会记录一些debug过程，Github对我来说作为托管代码、学习源码和记录学习过程的平台更要学会利用、经营。坚持写博客另一方面也是为今后写文档培养意识和兴趣。</p><p>附上一张昨晚拍的夕阳！🥂</p><p><img src="/2019/11/21/Github%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/image1.jpg" srcset="undefined" alt></p><p>Stay hungry. Stay foolish.</p>]]></content>
    
    
    
    <tags>
      
      <tag>Github</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>