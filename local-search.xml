<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Go语言学习笔记（三）</title>
    <link href="undefined2019/11/27/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <url>2019/11/27/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="day05">##Day05  :</h2><p>🌍<strong>并发编程</strong>🌏</p><h3 id="goroutine">goroutine  :</h3><p>轻量级“线程“</p><p><strong>非抢占式</strong>多任务处理，由协程主动交出控制权</p><p>编译器/解释器/虚拟机层面的多任务，具体执行由调度器完成</p><p>多个协程可以在一个或多个线程上运行</p><pre><code class="language-go">func main(){       var a [10] int    for i := 0 ;i&lt;10 ;i++{        go func(i int){            for{                            a[i]++                //runtime.Gosched()  //交出控制权，让其他goroutine有运行机会            }              }(i)    }       time.Sleep(time.Millisecond)    fmt.Println(a)}</code></pre><p>上面的代码简单展示了协程的工作方式，在函数前加上关键字go，表明这个函数交给main协程以外的协程由调度器执行，调度器会在合适的点进行切换。而关于协程相较于线程的轻量级，在于其主协程(main)和其他协程(…goroutine)可以相互访问。如下图：</p><p><img src="/2019/11/27/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/%E5%8D%8F%E7%A8%8BCoroutine.png" srcset="undefined" alt="协程Coroutine"></p><p>Go语言原生支持协程，Java的一些第三方的JVM对协程支持。</p><h4 id="goroutine-u-可能-u-切换的点：">goroutine<u>可能</u>切换的点：</h4><p><strong>I/O,select</strong></p><p><strong>channel</strong></p><p><strong>等待锁</strong></p><p><strong>函数调用</strong></p><p><strong>runtime.Gosched()</strong></p><p>⚠️<strong>多个协程会映射到一个线程里</strong></p><h3 id="channel-：">channel  ：</h3><p>🍨Go语言创造者：</p><p><strong>''不要通过共享内存来通信；通过通信来共享内存</strong>’’</p><pre><code class="language-go">import (       &quot;fmt&quot;    &quot;time&quot;)func worker(id int , c chan int) {    for{        n,ok := &lt;-c        if !ok{            break        }        fmt.Printf(&quot;Worker %d receive %d\n&quot;,id,n)    }}func createWorker(id int)chan &lt;- int {// &lt;- 定义这个channel是用来发数据的    c := make(chan int)    go worker(id,c)    return c}func channelDemo(){    //c == nil    //channel of int  channel里面的内容是int       var channels [10] chan &lt;- int       for i := 0; i&lt;10 ; i++{        channels [i] = createWorker(i)    }       for i:= 0 ; i&lt;10 ;i++{        channels[i] &lt;- 'A'+i       }       //n := &lt;-c             //收数据       //fmt.Println(s)            //直接运行会报deadlock    time.Sleep(time.Millisecond)}func bufferedChannel(){   //只有发没有收的channel会产生死锁    n := make(chan int , 3)  //设置缓冲区,不会产生deadlock    go worker(0,n)    n &lt;- 'a'    n &lt;- 'b'     n &lt;- 'c'    time.Sleep(time.Millisecond)}func channelClose(){    n := make(chan int , 3)//设置缓冲区,不会产生deadlock    go worker(0,n)    n &lt;- 'a'    n &lt;- 'b'    n &lt;- 'c'    close(n)    //会收到许多空数据    time.Sleep(time.Millisecond)}func main(){    // channelDemo()    // bufferedChannel()   //缓冲区在提升性能上是有帮助的       channelClose()}</code></pre><h4 id="使用channel等待goroutine结束：">使用channel等待goroutine结束：</h4><pre><code class="language-go">import (       &quot;fmt&quot;    &quot;sync&quot;)func doWork(id int , c chan int , wg *sync.WaitGroup) {    for n := range c{        fmt.Printf(&quot;Worker %d receive %c\n&quot;,id,n)        wg.Done()       }}type worker struct {    in chan int    wg *sync.WaitGroup}func createWorker(id int, wg *sync.WaitGroup) worker {    w := worker{        in: make(chan int),        wg: wg,    }    go doWork(id, w.in , wg)    return w}func channelDemo(){    var wg sync.WaitGroup     //等待多人完成任务    var workers [10] worker    for i := 0; i&lt;10 ; i++{        workers [i] = createWorker(i,&amp;wg)    }    wg.Add(20)    for i, worker := range  workers{        worker.in &lt;- 'A'+i    }    for i ,worker := range workers{        worker.in &lt;- 'a'+i    }    wg.Wait()       //wait for all of them    //time.Sleep(time.Millisecond)}func main(){    channelDemo()}</code></pre><h4 id="使用channel实现树的遍历：">使用channel实现树的遍历：</h4><pre><code class="language-go">func (node *Node)TraverseWithChannel() chan *Node{//channel里面一个一个节点去收    out := make(chan *Node)    go func() {        node.TraverseFunc(func(node *Node) {            out &lt;- node        })        close(out)    }()    return out}</code></pre><h3 id="select">select  :</h3><p>👊select 是 Go 中的一个控制结构，类似于用于通信的 switch 语句。每个 case 必须是一个通信操作，要么是发送要么是接收。</p><p>👊select 随机执行一个可运行的 case。如果没有 case 可运行，它将阻塞，直到有 case 可运行。一个默认的子句应该总是可运行的。</p><pre><code class="language-go">func generator() chan int{    out := make(chan int)    go func() {        i := 0        for{            time.Sleep(time.Duration(rand.Intn(1500))*                       time.Millisecond)            out &lt;- i            i++        }    }()    return out}func main() {    var c1, c2 = generator(),generator()    for {        select { //非阻塞            case n := &lt;-c1:            fmt.Println(&quot;Receive from c1:&quot;, n)            case n := &lt;-c2:            fmt.Println(&quot;Receive from c2:&quot;, n)        }    }}</code></pre><p>程序输出结果：</p><p><img src="/2019/11/27/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/selectTest.png" srcset="undefined" alt="selectTest"></p><h3 id="传统同步机制：">传统同步机制：</h3><p><strong>WaitGroup</strong></p><p><strong>Mutex (互斥量)</strong></p><p><strong>Cond</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解Java虚拟机学习笔记（二）</title>
    <link href="undefined2019/11/25/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>2019/11/25/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Go语言学习笔记（二）</title>
    <link href="undefined2019/11/25/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>2019/11/25/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h3 id="day03">##Day03  :</h3><h4 id="结构体和方法：">结构体和方法：</h4><p>🔌面向对象：go语言仅支持封装，不支持继承和多态</p><h5 id="结构的定义：">结构的定义：</h5><pre><code class="language-go">type TreeNode struct {    Left, Right *TreeNode    Value int}//切片定义nodes := []treeNode{{value:3},{},{6,nil,&amp;root},}</code></pre><p>为结构定义方法：</p><pre><code class="language-go">func (node treeNode) print(){    fmt.Println(node.value)}</code></pre><p>☑️Go语言虽然没有构造函数一说，但是可以通过工厂函数来控制。</p><pre><code class="language-go">func createNode(value int) *treeNode{    return &amp;treeNode{value:value}}</code></pre><h5 id="使用指针作为方法接收者：">使用指针作为方法接收者：</h5><pre><code class="language-go">func (node *treeNode)setValue(value int){    node.value=value}</code></pre><p>⚠️由于结构体是值传递，不存在引用传递。所以只有使用指针才可以改变结构内容。另：nil指针也可以调用方法。</p><h5 id="遍历结构函数：">遍历结构函数：</h5><p>接上述代码。定义一个树结构，并向其各个节点赋值：</p><pre><code class="language-go">    var root treeNode    root = treeNode{value:3}    root.left = &amp;treeNode{}    root.right = &amp;treeNode{5,nil,nil}    root.right.left = new(treeNode)    root.left.right = createNode(2)    root.right.left.setValue(4)</code></pre><p>中序遍历结构方法：</p><pre><code class="language-go">func (node *treeNode)Traverse(){//定义一个Traverse函数，函数接收者是指针类型的一个nodeif node == nil{return   }   node.left.Traverse()node.print()node.right.Traverse()}</code></pre><p><img src="/2019/11/25/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E7%BB%93%E6%9E%84%E5%87%BD%E6%95%B0%E6%89%93%E5%8D%B0%E7%BB%93%E6%9E%9C" srcset="undefined" alt="中序遍历结构函数打印结果"></p><hr><h4 id="包和封装：">包和封装：</h4><h5 id="定义：">定义：</h5><p>首字母大写：public</p><p>首字母小写：private</p><p>⚠️<strong>为一个结构定义的方法需要在同一个包内</strong></p><p>后序遍历结构函数：</p><pre><code class="language-go">type myTreeNode struct {    node *tree.Node}func (myNode *myTreeNode) postOrder(){//定义一个postOrder()函数，函数接收者是一个指针类型的myNode    if myNode == nil || myNode.node == nil{        return       }       //左右子树节点初始化    left := myTreeNode{myNode.node.Left}    left.postOrder()    right := myTreeNode{myNode.node.Right}    right.postOrder()    myNode.node.Print()}</code></pre><p><img src="/2019/11/25/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E7%BB%93%E6%9E%84%E5%87%BD%E6%95%B0%E6%89%93%E5%8D%B0%E7%BB%93%E6%9E%9C" srcset="undefined" alt="后序遍历结构函数打印结果"></p><hr><h4 id="接口：">接口：</h4><h5 id="接口定义：">接口定义：</h5><pre><code class="language-go">type Retriever interface {    Get(url string) string}func download (r Retriever) string{    return r.Get(&quot;http://www.baidu.com&quot;)}</code></pre><p>🦆“duck typing” 接口实现是隐式的，只要实现接口里的方法就行。</p><h5 id="接口的组合：">接口的组合：</h5><p>一个接口中可以整合其他接口或者方法</p><pre><code class="language-go">type RetrieverPoster interface {    Retriever    Poster    Connect(host string)}func session(r RetrieverPoster){    r.Get()    r.setValue()}</code></pre><hr><h4 id="函数式编程：">函数式编程：</h4><p>举例：</p><pre><code class="language-go">func adder() func(int)int{//定义adder()函数，类型是带有一个int参数，返回值是int的函数    sun := 0    return func (v int)int{        sun += v        return sun    }}func main(){    a := adder()    for i := 0; i &lt; 10; i++{        fmt.Println(a(i))    }}</code></pre><p>使用函数方法来遍历二叉树：</p><pre><code class="language-go">//重新定义一个遍历函数，与之前定义的Traverse函数不同，这里的TraverseFunc函数带有的参数是一个结构函数func (node *Node) TraverseFunc(f func(*Node)){    if node == nil{        return       }    node.Left.TraverseFunc(f)//这里f就是带有一个*Node参数的结构函数    f(node)    node.Right.TraverseFunc(f)}//修改后的遍历函数func (node *Node) Traverse(){node.TraverseFunc(func (n *Node){   //在函数体里调用重新定义好的函数n.Print()})}</code></pre><p>🕶至此，相较于定义函数来遍历二叉树，函数方法可以干的事情就更多了，而不局限于运行写好的函数体内容。</p><pre><code class="language-go">//在main()函数里可以添加节点计数器，直接调用重新定义的函数就可以了，十分简便！nodeCount := 0root.TraverseFunc(func (*tree.Node){    nodeCount ++})fmt.Println(&quot;nodeConut:&quot;,nodeCount)</code></pre><hr><h3 id="day04">##Day04  :</h3><h5 id="defer调用-：">defer调用  ：</h5><p>🌓defer关键字有几个特点：</p><p>*<strong>确保调用在函数结束时发生</strong></p><p>*<strong>参数在defer语句时计算</strong></p><p>*<strong>defer列表为先进后出</strong></p><pre><code class="language-go">//确保调用在函数结束时发生file,err := os.Create(filename) if err != nil{   panic(err)   }defer file.Close()  writer := bufio.NewWriter(file) defer writer.Flush()</code></pre><pre><code class="language-go">func tryDefer(){    for i := 0 ;i &lt; 100; i++{        defer fmt.Println(i)        if i==30{            panic (&quot;print too many!&quot;)        }       }}func main(){    tryDefer()}</code></pre><p><img src="/2019/11/25/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/%E5%8F%82%E6%95%B0%E5%9C%A8defer%E8%AF%AD%E5%8F%A5%E6%97%B6%E8%AE%A1%E7%AE%97" srcset="undefined" alt="参数在defer语句时计算"></p><p>对于错误处理要看文档</p><h5 id="panic">panic  :</h5><p>*<strong>停止当前函数执行</strong></p><p>*<strong>一直向上返回，执行每一层的defer</strong></p><p>*<strong>如果没有遇见recover，程序退出</strong></p><p>⏬</p><h5 id="recover">recover  :</h5><p>*<strong>仅在defer调用中使用</strong></p><p>*<strong>获取panic的值</strong></p><p>*<strong>如果无法处理，可重新panic</strong></p><pre><code class="language-go">func tryRecover(){   defer func(){    //匿名函数，只用写函数体    r := recover()    if err,ok := r.(error);ok{        fmt.Println(&quot;Error occurred&quot;,err)    }else {        panic(fmt.Sprintf(&quot;I dont know what to do : %v&quot;,r))    }   }()          //匿名函数所带参数        panic(errors.New(&quot;This is an error&quot;))                  //a := 5/5                     //fmt.Println(a)                  panic(123)                 }func main() {    tryRecover()} </code></pre><p><img src="/2019/11/25/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/panic&amp;recover" srcset="undefined" alt="panic&amp;amp;recover"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解Java虚拟机学习笔记</title>
    <link href="undefined2019/11/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>2019/11/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="day01">Day01</h2><h3 id="第2章-java内存区域与内存溢出异常">第2章  Java内存区域与内存溢出异常</h3><h4 id="2-2-运行时数据区域">2.2  运行时数据区域</h4><h5 id="2-2-1-程序计数器">2.2.1  程序计数器</h5><p>▶️字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。分支、循环、跳转、异常处理、线程恢复等基础功能都需要这个计数器完成。</p><h5 id="2-2-2-虚拟机栈">2.2.2  虚拟机栈</h5><p>▶️是线程私有的，它的生命周期与线程相同，其描述的是Java方法执行的内存模型。每个方法执行时都会创建一个“栈帧”，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用到执行完成的过程，就对应着一个虚拟机栈的入栈出栈的过程。 <em>(:з」∠)</em>_</p><p>局部变量表存放了各种基本数据类型、对象引用。64位长度的long和double占用2个局部变量空间(Slot)，其余类型只占用1个。</p><p><strong>在Java虚拟机规范中，对这个区域规定了两种异常情况：</strong></p><p>1、如果线程请求的栈深度大于虚拟机所允许的深度，将抛出<strong>StackOverflowError</strong>异常；</p><p>2、如果虚拟机栈可以动态扩展，扩展时无法申请到足够的内存，就会抛出<strong>OutOfMemoryError</strong>异常；</p><h5 id="2-2-3-本地方法栈">2.2.3  本地方法栈</h5><p>为虚拟机使用到的native方法服务。也会抛上述两种异常。</p><h5 id="2-2-4-java堆">2.2.4  Java堆</h5><p>▶️Java堆是被所有线程共享的一块内存区域，在虚拟机创建时启动。存放对象实例，也是垃圾收集器管理的主要区域。如果堆中没有内存完成实例分配，并且堆也无法再扩展时，会抛出<strong>OutOfMemoryError</strong>异常。</p><p>✒️分配内存：</p><p><code>if(内存归整){</code></p><p><code>用过的内存放一边，没用的在另一边，内存写入时，移动分界点位置的指针，完成内存分配。---指针碰撞</code></p><p><code>}</code></p><p><code>if(内存不归整){</code></p><p><code>维护一个列表，记录哪些内存块是可用的，分配的时候找一块足够大的空间分划给对象，并更新表上的记录。---空闲列表</code></p><p><code>}</code></p><h5 id="2-2-5-方法区">2.2.5  方法区</h5><p>▶️存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p><p>当方法区无法满足内存分配时，会抛出<strong>OutOfMemoryError</strong>异常。</p><h5 id="2-2-6-运行时常量池">2.2.6  运行时常量池</h5><p>▶️是方法区的一部分，字面量和符号引用在类加载后进入方法区的运行时常量池中存放，具有动态性。在常量池无法申请到内存时会抛出<strong>OutOfMemoryError</strong>异常。</p><h4 id="2-3-hotspot虚拟机对象探秘">2.3  HotSpot虚拟机对象探秘</h4><h5 id="2-3-1-对象的创建">2.3.1  对象的创建</h5><p>▶️虚拟机遇到new指令时，首先检查指令的参数是否能在常量池中定位到一个类的符号引用，并检查这个符号是否已被加载、解析和初始化过，如果没有，就先执行类加载过程。-&gt;通过检查后，分配内存（<strong>指针碰撞、空闲列表</strong>）。</p><h5 id="2-3-2-对象的内存布局">2.3.2  对象的内存布局</h5><p>对象在内存中存储的布局分为3块区域：对象头、实例数据和对齐填充。</p><h5 id="2-3-3-对象的访问定位">2.3.3  对象的访问定位</h5><p>Java程序通过栈上的reference数据来操作堆上的具体对象。对象的访问方式目前主流的方式是使用句柄和直接指针两种。</p><p>☑️<strong>使用句柄访问</strong></p><p>Java堆中会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体信息。</p><p><img src="/2019/11/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%80%9A%E8%BF%87%E5%8F%A5%E6%9F%84%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1.png" srcset="undefined" alt="通过句柄访问对象"></p><p>☑️<strong>直接指针访问</strong></p><p>Java堆中的布局就必须考虑如何放置访问类型数据的相关信息。而reference中存储的直接就是对象地址。</p><p><img src="/2019/11/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%80%9A%E8%BF%87%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1.png" srcset="undefined" alt="通过直接指针访问对象"></p><hr><h3 id="第3章-垃圾收集器与内存分配策略">第3章  垃圾收集器与内存分配策略</h3><h4 id="3-1-对象已死吗">3.1  对象已死吗</h4><h5 id="3-2-1引用计数算法">3.2.1引用计数算法</h5><p>▶️给对象中添加一个引用计数器，每当有一个地方引用它时，计数器就加1；当引用失效时，计数器就减1。任何时刻计数器为零的对象就是不可能再被使用的。该算法存在缺陷，并不是虚拟机来判断对象是否存活的方法。</p><h5 id="3-2-2-可达性分析算法">3.2.2  可达性分析算法</h5><p>▶️算法基本思路是通过一系列称为 “GC Root” 的对象作为起始点，从这些节点向下搜索，搜索走过的路就是通过一系列称为引用链，当一个对象到GC Root没有任何引用链相连（对象不可达），则证明此对象是不可用的，需要被回收。</p><h5 id="3-2-3-再谈引用">3.2.3  再谈引用</h5><p>JDK1.2之后，Java对引用的概念进行了扩充。分为强引用、软引用、弱引用、虚引用。</p><p>🥇<strong>□强引用</strong></p><p>代码中普遍存在，类似<code>Object obj = new Object()</code>，只要强引用存在，垃圾收集器永远不会回收掉被引用的对象。</p><p>🥈<strong>□软引用</strong></p><p>描述一些还有用但是非必须的对象。系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常，在1.2之后，提供了SoftReference类来实现软引用。</p><p>🥉<strong>□弱引用</strong></p><p>也是用来描述非必须的对象，被弱引用关联的对象智能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否够用，都会回收掉只被弱引用关联的对象。1.2之后提供了WeakReference类实现弱引用。</p><p>✴️<strong>□虚引用</strong></p><h5 id="3-2-4-生存还是死亡">3.2.4  生存还是死亡</h5><p>关于finalize()方法，对象在被回收前会对自己进行一次自救。</p><h4 id="3-4-hotspot的算法实现">3.4  HotSpot的算法实现</h4><h5 id="3-4-1-枚举根节点">3.4.1  枚举根节点</h5><p>挨个通过GC Root寻找引用链，存在系统停顿。</p><h5 id="3-4-2-安全点">3.4.2  安全点</h5><p>。。。。。。。。。。。。</p><h5 id="3-4-3-安全区域">3.4.3  安全区域</h5><p>安全区域指在一段代码片段中，引用关系不会发生改变，在这个区域中的任意地方开始GC都是安全的。也可以把Safe Region 看做是被扩展了的Safepoint。</p><h4 id="3-5-垃圾收集器-з">3.5  垃圾收集器       <em>(:з」∠)</em>_</h4><h5 id="3-5-1-serial收集器">3.5.1  Serial收集器</h5><p>✒️Serial收集器是最基本、发展历史最久的收集器。单线程，而且在收集工作进行时必须暂停其他所有工作线程，直到收集结束。但是简单高效，运行在新生代垃圾收集的区域，对于在Client模式下的虚拟机来说是一个很好的选择。</p><h5 id="3-5-2-parnew收集器">3.5.2  ParNew收集器</h5><p>✒️ParNew收集器是多线程版本的Serial收集器。在控制参数、收集算法、Stop The World、对象分配规则、回售策略与Serial收集器相同。适合Server模式的新生代收集器。目前，除了Serial收集器，只有ParNew收集器可以跟CMS收集器配合。</p><h5 id="3-5-3-parallel-scavenge收集器">3.5.3  Parallel Scavenge收集器</h5><p>✒️新生代复制算法收集器。侧重点在达到一个可控制的吞吐量（CPU运行用户代码所耗时间/CPU消耗总时间）。</p><h5 id="3-5-4-serial-old收集器">3.5.4  Serial Old收集器</h5><p>✒️是Serial老年代的版本。单线程，使用标记-整理算法。适合Client模式下的虚拟机，但如果在Server模式下，还有两大用途：在JDK1.5以前的版本中与Parallel Scavcenge收集器搭配使用；另一种就是CMS的后备预案</p>]]></content>
    
    
    
    <tags>
      
      <tag>JavaVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go语言学习笔记</title>
    <link href="undefined2019/11/21/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>2019/11/21/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="go语言学习笔记">Go语言学习笔记</h2><h3 id="day01-：">##Day01  ：</h3><h4 id="函数：">函数：</h4><h5 id="函数的定义">函数的定义:</h5><p>**·**func xxx(函数名)（携带的参数）函数的返回值{</p><p>/*      函数体      */</p><p>}</p><p>eg:</p><p><code>func minus(a,b int , op string ) int{}</code></p><p><code>func div(c,d int)(int,int){}</code></p><p><code>func multiply(e,f int)(g,h int){}</code></p><p><strong>·</strong>▶️作为函数式编程的语言，在Go语言中一个函数可以有多个返回值，在声明返回值的<code>return</code>语句中多个返回值中间用<code>,</code>隔开。</p><p><strong>·</strong>▶️如果在定义函数返回值时不想使用某个参数，在参数位上输入<code>_</code>下划线即可</p><p><strong>·</strong>🏴函数式编程规范：</p><p><code>func apply(func op(int , int) int , a , b int )int{</code></p><p><strong>·</strong>⏫解析：在apply函数中传入的参数是op这个函数和a,b两个int类型的变量，op函数返回值是int，自带两个int类型参数。</p><p><strong>·</strong>🛰定义一个参数列表：</p><pre><code class="language-go">func sum(numbers ...int) int{    s :=0   for i := range numbers{        s+= numbers[i]       }    return s}</code></pre><hr><h4 id="指针：">指针：</h4><p>⚡️Go语言指针没有运算，只存在值传递</p><h5 id="指针的定义：">指针的定义：</h5><p><code>var a int =3</code></p><p><code>var pa *int = &amp;a</code></p><p><code>*pa = 3</code></p><p><code>fmt.Println(*pa,pa)</code></p><p>▶️打印结果是:3  0xc000000a088</p><p>但是多次运行发现打印的地址都不一样，这与初始化内存空间有关。</p><p>指针值传递代码</p><p><code>func swap(a,s *int)(int,int){</code></p><p>​<code>*s,*a = *a,*s</code></p><p><code>}</code></p><p><code>func main(){</code></p><p>​<code>a:=3,s:=5</code></p><p>​<code>swap(&amp;a,&amp;s)</code></p><p>​<code>fmt.Println(a,s)</code></p><p><code>}</code></p><p><strong>·</strong>☑️打印结果是：5 , 3</p><hr><h4 id="数组">数组</h4><p>func f(arr[5]int){</p><p>//函数体</p><p>}</p><p><strong>·</strong>🥊数组是值类型，调用该函数相当于拷贝。可以用指针数组传值。</p><h5 id="数组的定义：">数组的定义：</h5><p><code>var array1 [5] int</code></p><p><code>array2:= [3]int {1,2,3}</code></p><p><code>array3:=[...]int{1,2,3,4,5}</code></p><p><code>var grid [4][5] bool</code></p><p>数组遍历：</p><p><code>for i:=0;i&lt;len(arr2);i+{</code></p><p><code>fmt.Println(arr2[i])</code></p><p><code>}</code></p><p><code>for i,r:= range arr1{//i：下标；r：数值；</code></p><p>​<code>fmt.Println(i,r)</code></p><p><code>}</code></p><hr><h3 id="day02-：">##Day02  ：</h3><h4 id="切片：">切片：</h4><h5 id="切片的定义：">切片的定义：</h5><pre><code class="language-go">var s []int  //zero value for slice is nil</code></pre><p>eg:</p><pre><code class="language-go">arr := [...]int{0,1,2,3,4,5,6,7}fmt.Println(&quot;arr[2:6] =&quot;,arr[2:6])fmt.Println(&quot;arr[:6] =&quot;,arr[:6])s1 := arr[2:]fmt.Println(&quot;arr[2:]&quot;, s1)s2 := arr[:]fmt.Println(&quot;arr[:] =&quot;, s2)</code></pre><p>⏬<strong>Slice本身没有数据，是对底层array的一个view</strong>，其中Slice本身有一个数据结构 :</p><pre><code class="language-go">func updateSlice(s []int){//定义一个updateSlice函数,观察Slice的打印结果s[0]=100}fmt.Println(&quot;updateSlice s1:&quot;)updateSlice(s1)fmt.Println(s1)fmt.Println(arr)fmt.Println(&quot;updateSlice s2:&quot;)updateSlice(s2)fmt.Println(s2)fmt.Println(arr)</code></pre><p><img src="/2019/11/21/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C1.png" srcset="undefined" alt="运行结果1"></p><p>可以看出，Slice不是值类型的。</p><p><strong>ReSlice</strong></p><pre><code class="language-go">fmt.Println(&quot;ReSlice: &quot;)arr[0],arr[2]=0,2//先把元素赋值回来s1=arr[2:6]s2=s1[3:5]fmt.Println(s1)fmt.Println(s2)</code></pre><p><img src="/2019/11/21/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C2.png" srcset="undefined" alt="运行结果2"></p><p>⚠️<strong>注意：Slice可以向前扩展，不可以向后扩展，Slice底层有两个参数：len(长度)、cap(容量)</strong></p><p>Slice底层</p><p><img src="/2019/11/21/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Slice%E5%BA%95%E5%B1%82.png" srcset="undefined" alt="Slice底层"></p><p>ReSlice底层</p><p><img src="/2019/11/21/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ReSlice%E5%BA%95%E5%B1%82.png" srcset="undefined" alt="ReSlice底层"></p><h5 id="切片的使用">切片的使用</h5><pre><code class="language-go">func printslice(s []int){    fmt.Printf(&quot;%v,len=%d,cap=%d\n&quot;,s,len(s),cap(s))}</code></pre><p>🔼定义了一个用于打印切片元素信息的函数</p><p>🌳从中部删除切片中的元素：</p><pre><code class="language-go">fmt.Println(&quot;Deleting elements from slice&quot;)s2=append(s2[:3],s2[4:]...)printslice(s2)</code></pre><p>🌳从切片头部删除元素：</p><pre><code class="language-go">fmt.Println(&quot;Popping from front&quot;)front := s2[0]s2 = s2[1:]fmt.Println(front)printslice(s2)</code></pre><p>🌳从切片尾部删除元素：</p><pre><code class="language-go">fmt.Println(&quot;Popping from back&quot;)tail := s2[len(s2) -1]s2 = s2[:len(s2)-1]fmt.Println(tail)printslice(s2)</code></pre><hr><h4 id="map">Map :</h4><h5 id="map的创建：">Map的创建：</h5><pre><code class="language-go">m := map[string]string{    &quot;name&quot;: &quot;kalyhu&quot;,    &quot;course&quot;: &quot;golang&quot;,    &quot;site&quot;: &quot;Bilibili&quot;,    &quot;quality&quot;: &quot;notBad&quot;}//mapK[V],map[K1]map[K2]V</code></pre><h5 id="map的操作：">Map的操作：</h5><p>创建：<code>make map[string]int</code></p><p>获取元素：<code>m[key]</code></p><p>通过使用<code>value,ok :=m[key]</code>来判断是否存在key</p><pre><code class="language-go">fmt.Println(&quot;Getting values&quot;)courseName , ok:= m[&quot;course&quot;]fmt.Println(courseName,ok)if courseName,ok := m[&quot;couse&quot;];ok{    fmt.Println(courseName)}else {     fmt.Println(&quot;key does not exist !&quot;)}fmt.Println(&quot;Deleting values&quot;)name , ok := m[&quot;name&quot;]fmt.Println(name,ok)delete(m,&quot;name&quot;)//由于key：name被删掉了，下面的ok将会打印出falsename , ok = m[&quot;name&quot;]fmt.Println(name,ok)</code></pre><p><img src="/2019/11/21/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Map%E7%9A%84%E6%93%8D%E4%BD%9C.png" srcset="undefined" alt="Map的操作"></p><p>☑️遍历Map</p><p>使用range遍历key，或者遍历key，value对。但不保证遍历顺序，如要顺序需手动对key排序。</p><hr><h4 id="字符和字符串处理：">字符和字符串处理：</h4><p>字符：rune  (int32)、byte(uint8)   字符串：string</p><pre><code class="language-go">s := &quot;你好，Go语言!&quot;fmt.Println(s)for _,b := range []byte(s){    fmt.Printf(&quot;%X &quot;,b)}fmt.Println()for i,ch := range s{//ch is a rune       fmt.Printf(&quot;(%d,%X) &quot;,i,ch)}fmt.Println()</code></pre><p><img src="/2019/11/21/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%89%93%E5%8D%B0%E7%BB%93%E6%9E%9C.png" srcset="undefined" alt="字符串打印结果"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Github的第一篇博客</title>
    <link href="undefined2019/11/21/Github%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
    <url>2019/11/21/Github%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<p>写博客总是能让我静心，来Github上我就选择不记录技术以外的生活，相较于博客园我会记录一些debug过程，Github对我来说作为托管代码、学习源码和记录学习过程的平台更要学会利用、经营。坚持写博客另一方面也是为今后写文档培养意识和兴趣。</p><p>附上一张昨晚拍的夕阳！🥂</p><p><img src="/2019/11/21/Github%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/image1.jpg" srcset="undefined" alt></p><p>Stay hungry. Stay foolish.</p>]]></content>
    
    
    
    <tags>
      
      <tag>Github</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>